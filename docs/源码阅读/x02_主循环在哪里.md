# 01. 主循环在哪里？

从 Linux 来看, run 启动 loop:

1. 处理`窗口`的待处理事件 -> `DisplayServer::get_singleton()->process_events()`
    * DisplayServer 提供 `窗口管理+事件+提供渲染API`
2. 手柄输入,
3. 引擎迭代 -> `Main::iteration`

```c++
// platform/linuxbsd/os_linuxbsd.cpp 中的 run() 函数是事件循环的核心
void OS_LinuxBSD::run() {
    if (!main_loop) {
        return;
    }

    main_loop->initialize();

    while (true) {
        DisplayServer::get_singleton()->process_events(); // 关键：处理系统事件
#ifdef SDL_ENABLED // 这里通过宏判断是否能启用SDL, 从而处理游戏手柄事件
        if (joypad_sdl) {
            joypad_sdl->process_events(); // 关键：处理游戏手柄事件
        }
#endif
        if (Main::iteration()) { // 关键：引擎主迭代, 这里默认false, 只有退出时才返回true
            break;
        }
    }

    main_loop->finalize();
}
```

# 02. Main::iteration() 函数详细分析与注释

这段代码, 大致 8 个段落:

1. 初始化状态, 计算这一帧(本次循环)的时间 tick
2. xr 相关处理
3. 触发物理引擎计算
4. 处理输入事件
5. 执行场景逻辑(nodes)
6. 根据上面的, 渲染出图
7. 性能统计, 调试
8. 退出条件检查

`Main::iteration()` 是 Godot 引擎主循环的核心函数，负责处理每一帧的逻辑更新、物理模拟和渲染操作。下面是对该函数的详细拆解和注释：

## 1. 计算这一帧的状态 (时间 tick, 物理 tick, 退出状态)

```cpp
bool Main::iteration() {
    // 增加迭代计数器
    iterating++;

    // 获取当前时间戳并更新引擎状态
    const uint64_t ticks = OS::get_singleton()->get_ticks_usec();
    Engine::get_singleton()->_frame_ticks = ticks;
    main_timer_sync.set_cpu_ticks_usec(ticks);
    main_timer_sync.set_fixed_fps(fixed_fps);

    // 计算自上一帧以来经过的时间
    const uint64_t ticks_elapsed = ticks - last_ticks;

    // 获取物理设置参数
    const int physics_ticks_per_second = Engine::get_singleton()->get_user_physics_ticks_per_second();
    const double physics_step = 1.0 / physics_ticks_per_second;

    // 获取时间缩放因子
    const double time_scale = Engine::get_singleton()->get_effective_time_scale();

    // 计算时间步长
    MainFrameTime advance = main_timer_sync.advance(physics_step, physics_ticks_per_second);
    double process_step = advance.process_step;
    double scaled_step = process_step * time_scale;

    // 更新引擎状态
    Engine::get_singleton()->_process_step = process_step;
    Engine::get_singleton()->_physics_interpolation_fraction = advance.interpolation_fraction;

    // 初始化性能计数器
    uint64_t physics_process_ticks = 0;
    uint64_t process_ticks = 0;
#if !defined(NAVIGATION_2D_DISABLED) || !defined(NAVIGATION_3D_DISABLED)
    uint64_t navigation_process_ticks = 0;
#endif

    // 累加帧时间
    frame += ticks_elapsed;
    last_ticks = ticks;

    // 限制每帧物理步数
    const int max_physics_steps = Engine::get_singleton()->get_user_max_physics_steps_per_frame();
    if (fixed_fps == -1 && advance.physics_steps > max_physics_steps) {
        process_step -= (advance.physics_steps - max_physics_steps) * physics_step;
        advance.physics_steps = max_physics_steps;
    }

    bool exit = false;
```

## 2. XR 处理

```cpp
    // 处理 XR（扩展现实）系统
#ifndef XR_DISABLED
    XRServer::get_singleton()->_process();
#endif
```

## 3. 物理模拟循环

```cpp
    // 执行指定次数的物理步进
    for (int iters = 0; iters < advance.physics_steps; ++iters) {
        // 如果启用了敏捷输入事件刷新，则刷新缓冲的事件
        if (Input::get_singleton()->is_agile_input_event_flushing()) {
            Input::get_singleton()->flush_buffered_events();
        }

        // 设置引擎状态为物理处理中
        Engine::get_singleton()->_in_physics = true;
        Engine::get_singleton()->_physics_frames++;

        // 记录物理处理开始时间（用于性能统计）
        uint64_t physics_begin = OS::get_singleton()->get_ticks_usec();

        // 准备插值节点 - 在物理服务器更新前进行，确保变换插值正确
        OS::get_singleton()->get_main_loop()->iteration_prepare();

        // 3D 物理同步和查询刷新
#ifndef PHYSICS_3D_DISABLED
        PhysicsServer3D::get_singleton()->sync();
        PhysicsServer3D::get_singleton()->flush_queries();
#endif

        // 2D 物理同步和查询刷新
#ifndef PHYSICS_2D_DISABLED
        PhysicsServer2D::get_singleton()->sync();
        PhysicsServer2D::get_singleton()->flush_queries();
#endif

        // 调用主循环的物理处理函数，如果返回 true 则退出
        if (OS::get_singleton()->get_main_loop()->physics_process(physics_step * time_scale)) {
#ifndef PHYSICS_3D_DISABLED
            PhysicsServer3D::get_singleton()->end_sync();
#endif
#ifndef PHYSICS_2D_DISABLED
            PhysicsServer2D::get_singleton()->end_sync();
#endif
            Engine::get_singleton()->_in_physics = false;
            exit = true;
            break;
        }

        // 导航系统物理处理
#if !defined(NAVIGATION_2D_DISABLED) || !defined(NAVIGATION_3D_DISABLED)
        uint64_t navigation_begin = OS::get_singleton()->get_ticks_usec();

#ifndef NAVIGATION_2D_DISABLED
        NavigationServer2D::get_singleton()->physics_process(physics_step * time_scale);
#endif
#ifndef NAVIGATION_3D_DISABLED
        NavigationServer3D::get_singleton()->physics_process(physics_step * time_scale);
#endif

        // 更新导航处理时间统计
        navigation_process_ticks = MAX(navigation_process_ticks, OS::get_singleton()->get_ticks_usec() - navigation_begin);
        navigation_process_max = MAX(OS::get_singleton()->get_ticks_usec() - navigation_begin, navigation_process_max);

        // 刷新消息队列
        message_queue->flush();
#endif

        // 执行物理步进
#ifndef PHYSICS_3D_DISABLED
        PhysicsServer3D::get_singleton()->end_sync();
        PhysicsServer3D::get_singleton()->step(physics_step * time_scale);
#endif

#ifndef PHYSICS_2D_DISABLED
        PhysicsServer2D::get_singleton()->end_sync();
        PhysicsServer2D::get_singleton()->step(physics_step * time_scale);
#endif

        // 再次刷新消息队列
        message_queue->flush();

        // 结束迭代
        OS::get_singleton()->get_main_loop()->iteration_end();

        // 更新物理处理时间统计
        physics_process_ticks = MAX(physics_process_ticks, OS::get_singleton()->get_ticks_usec() - physics_begin);
        physics_process_max = MAX(OS::get_singleton()->get_ticks_usec() - physics_begin, physics_process_max);

        // 设置引擎状态为非物理处理中
        Engine::get_singleton()->_in_physics = false;
    }
```

## 4. 输入事件刷新

```cpp
    // 再次刷新输入事件缓冲区
    if (Input::get_singleton()->is_agile_input_event_flushing()) {
        Input::get_singleton()->flush_buffered_events();
    }
```

## 5. 场景处理

个人认为最重要的是触发 process 函数

```cpp
    // 记录场景处理开始时间
    uint64_t process_begin = OS::get_singleton()->get_ticks_usec();

    // 调用主循环的处理函数，如果返回 true 则退出
    if (OS::get_singleton()->get_main_loop()->process(process_step * time_scale)) {
        exit = true;
    }

    // 刷新消息队列
    message_queue->flush();

    // 导航系统场景处理
#ifndef NAVIGATION_2D_DISABLED
    NavigationServer2D::get_singleton()->process(process_step * time_scale);
#endif
#ifndef NAVIGATION_3D_DISABLED
    NavigationServer3D::get_singleton()->process(process_step * time_scale);
#endif
```

## 6. 渲染处理

```cpp
    // 同步渲染服务器
    RenderingServer::get_singleton()->sync();

    // 检查是否有待处理的资源和是否需要呈现
    const bool has_pending_resources_for_processing = RD::get_singleton() && RD::get_singleton()->has_pending_resources_for_processing();
    bool wants_present = (DisplayServer::get_singleton()->can_any_window_draw() ||
                                 DisplayServer::get_singleton()->has_additional_outputs()) &&
            RenderingServer::get_singleton()->is_render_loop_enabled();

    // 如果需要呈现或有待处理资源
    if (wants_present || has_pending_resources_for_processing) {
        wants_present |= force_redraw_requested;

        // 在低处理器使用模式下优化绘制
        if ((!force_redraw_requested) && OS::get_singleton()->is_in_low_processor_usage_mode()) {
            if (RenderingServer::get_singleton()->has_changed()) {
                RenderingServer::get_singleton()->draw(wants_present, scaled_step);
                Engine::get_singleton()->increment_frames_drawn();
            }
        } else {
            // 正常绘制
            RenderingServer::get_singleton()->draw(wants_present, scaled_step);
            Engine::get_singleton()->increment_frames_drawn();
            force_redraw_requested = false;
        }
    }
```

## 7. 性能统计和调试

```cpp
    // 计算处理时间并更新最大值统计
    process_ticks = OS::get_singleton()->get_ticks_usec() - process_begin;
    process_max = MAX(process_ticks, process_max);
    uint64_t frame_time = OS::get_singleton()->get_ticks_usec() - ticks;

    // GDExtension 和脚本语言帧处理
    GDExtensionManager::get_singleton()->frame();
    for (int i = 0; i < ScriptServer::get_language_count(); i++) {
        ScriptServer::get_language(i)->frame();
    }

    // 音频服务器更新
    AudioServer::get_singleton()->update();

    // 调试器迭代处理
    if (EngineDebugger::is_active()) {
        EngineDebugger::get_singleton()->iteration(frame_time, process_ticks, physics_process_ticks, physics_step);
    }

    // 帧计数和 FPS 统计
    frames++;
    Engine::get_singleton()->_process_frames++;

    // 每秒更新一次 FPS 显示
    if (frame > 1000000) {
        // 等待几秒后再打印 FPS，因为引擎启动后立即报告的 FPS 不准确
        if (hide_print_fps_attempts == 0) {
            if (editor || project_manager) {
                if (print_fps) {
                    print_line(vformat("Editor FPS: %d (%s mspf)", frames, rtos(1000.0 / frames).pad_decimals(2)));
                }
            } else if (print_fps || GLOBAL_GET("debug/settings/stdout/print_fps")) {
                print_line(vformat("Project FPS: %d (%s mspf)", frames, rtos(1000.0 / frames).pad_decimals(2)));
            }
        } else {
            hide_print_fps_attempts--;
        }

        // 更新引擎 FPS 和性能统计
        Engine::get_singleton()->_fps = frames;
        performance->set_process_time(USEC_TO_SEC(process_max));
        performance->set_physics_process_time(USEC_TO_SEC(physics_process_max));
        performance->set_navigation_process_time(USEC_TO_SEC(navigation_process_max));

        // 重置统计值
        process_max = 0;
        physics_process_max = 0;
        navigation_process_max = 0;

        // 重置帧计数器
        frame %= 1000000;
        frames = 0;
    }

    // 减少迭代计数器
    iterating--;

    // 电影写入器处理
    if (movie_writer) {
        movie_writer->add_frame();
    }
```

## 8. 退出条件检查

```cpp
#ifdef TOOLS_ENABLED
    bool quit_after_timeout = false;
#endif

    // 检查是否达到指定的迭代次数
    if ((quit_after > 0) && (Engine::get_singleton()->_process_frames >= quit_after)) {
#ifdef TOOLS_ENABLED
        quit_after_timeout = true;
#endif
        exit = true;
    }

    // 在工具模式下等待资源导入完成
#ifdef TOOLS_ENABLED
    if (wait_for_import && EditorFileSystem::get_singleton() && EditorFileSystem::get_singleton()->doing_first_scan()) {
        exit = false;
    }
#endif

    // 如果设置了固定 FPS，则直接返回
    if (fixed_fps != -1) {
        return exit;
    }

    // 检查是否需要为事件唤醒
    SceneTree *scene_tree = SceneTree::get_singleton();
    bool wake_for_events = scene_tree && scene_tree->is_accessibility_enabled();

    // 添加帧延迟
    OS::get_singleton()->add_frame_delay(DisplayServer::get_singleton()->window_can_draw(), wake_for_events);

    // 自动构建解决方案（如 C# 项目）
#ifdef TOOLS_ENABLED
    if (auto_build_solutions) {
        auto_build_solutions = false;
        // 只在编辑器模式下相关
        if (!editor) {
            OS::get_singleton()->set_exit_code(EXIT_FAILURE);
            ERR_FAIL_V_MSG(true,
                    "Command line option --build-solutions was passed, but no project is being edited. Aborting.");
        }
        if (!EditorNode::get_singleton()->call_build()) {
            OS::get_singleton()->set_exit_code(EXIT_FAILURE);
            ERR_FAIL_V_MSG(true,
                    "Command line option --build-solutions was passed, but the build callback failed. Aborting.");
        }
    }
#endif

    // 编辑器退出时卸载插件
#ifdef TOOLS_ENABLED
    if (exit && quit_after_timeout && EditorNode::get_singleton()) {
        EditorNode::get_singleton()->unload_editor_addons();
    }
#endif

    return exit;
}
```

## 核心概念说明

1. **时间同步**：使用 `main_timer_sync` 来管理物理和处理步长，确保时间同步
2. **物理处理**：在固定时间步长下执行物理模拟，保证物理计算的稳定性
3. **插值**：通过 `_physics_interpolation_fraction` 实现平滑的视觉效果
4. **性能统计**：跟踪各种处理时间，用于调试和优化
5. **模块化设计**：通过条件编译支持不同的功能模块（2D/3D 物理、导航等）

# 脚本在那初始化与触发?

在 Godot 引擎中使用 GDScript 时，`Main::iteration()`函数中的以下部分是主要支撑逻辑：
这是 GDScript `_process()` 和 `_physics_process()` 回调执行的主要位置。

## 1. 主循环控制和脚本执行

```cpp
// 场景处理部分是GDScript执行的核心
uint64_t process_begin = OS::get_singleton()->get_ticks_usec();

if (OS::get_singleton()->get_main_loop()->process(process_step * time_scale)) {
    exit = true;
}
message_queue->flush();
```

这是 GDScript `_process()` 回调执行的主要位置。

## 2. 脚本语言框架支持

```cpp
// GDScript和其他脚本语言的帧处理
for (int i = 0; i < ScriptServer::get_language_count(); i++) {
    ScriptServer::get_language(i)->frame();
}
```

GDScript 作为脚本语言需要在每帧进行状态更新和垃圾回收。

## 3. 物理处理中的脚本回调

```cpp
for (int iters = 0; iters < advance.physics_steps; ++iters) {
    // ...

    // 这里会触发GDScript的_physics_process回调
    if (OS::get_singleton()->get_main_loop()->physics_process(physics_step * time_scale)) {
        // ...
    }

    // ...
}
```

## 4. 消息队列处理

```cpp
// 刷新消息队列，处理GDScript中的延迟调用
message_queue->flush();
```

GDScript 中的[call_deferred()](./core/variant/callable.h#L77-L84)等延迟调用在这里执行。

扩展知识: [call_deferred()详解](./call_deferred.md)

## 5. 场景树相关处理

```cpp
SceneTree *scene_tree = SceneTree::get_singleton();
bool wake_for_events = scene_tree && scene_tree->is_accessibility_enabled();
```

GDScript 通常与场景树节点交互，场景树的状态影响脚本执行。

## GDScript 支撑架构的关键组件

### 核心支撑系统：

1. **ScriptServer** - 管理 GDScript 语言实例
2. **SceneTree** - 提供场景节点树结构，GDScript 主要操作对象
3. **MessageQueue** - 处理延迟调用和信号
4. **Object** - 所有可脚本化对象的基类

### GDScript 执行流程：

1. **初始化阶段**：注册 GDScript 语言到 ScriptServer
2. **编译阶段**：将 GDScript 源码编译为字节码
3. **运行时阶段**：
   - 每帧通过`ScriptServer::frame()`更新状态
   - 通过`MainLoop::process()`调用脚本中的[\_process()](file:///home/kevin/cache/godot/servers/xr/xr_server.h#L235-L235)方法
   - 通过`MainLoop::physics_process()`调用`_physics_process()`方法
   - 通过`message_queue->flush()`处理延迟调用

### 在 Main::setup()中对 GDScript 的初始化：

```cpp
// 在setup过程中会注册脚本语言
register_core_singletons();
register_scene_types();
// ...
initialize_modules(MODULE_INITIALIZATION_LEVEL_SCENE);
```

GDScript 的支撑逻辑主要依赖于 Godot 的面向对象系统和信号系统，通过 C++层提供底层功能，而逻辑实现则由 GDScript 完成。`Main::iteration()`确保这些脚本回调按正确的顺序和时间间隔执行。

> 查看了以下源码, 有两个setup, setup还触发了setup2, 
>
> 为了跨平台分割为两个`setup`, 比如android可以在onResume时触发`setup2`
>
> 1. 基础环境设置（setup）- 快速、轻量、平台无关
> 2. 重型资源初始化（setup2）- 依赖显示、音频、渲染等系统

# 03. DisplayServer
DisplayServer 是一个抽象基类，为不同的显示后端（如 X11、Wayland、Windows、macOS 等）提供统一的接口。它的主要职责包括：

1. 窗口管理 - 创建、销毁、配置窗口
2. 事件处理 - 处理输入事件、窗口事件
3. 渲染上下文管理 - 为不同的渲染 API 创建上下文
4. 输入设备管理 - 鼠标、键盘、触摸、手写板等

这个process_events大致包括
```c++
// 处理来自操作系统的事件，如：
// - 窗口大小改变
// - 窗口焦点变化
// - 窗口关闭请求
// - 显示器连接/断开
// 处理各种输入设备的事件：
// - 鼠标移动、点击
// - 键盘按键
// - 触摸事件
// - 手写板输入
// 更新窗口的各种状态信息：
// - 位置、大小
// - 可见性
// - 焦点状态
```


